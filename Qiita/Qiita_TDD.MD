『テスト駆動開発による組み込みプログラミング』を読んで学んだこと


『テスト駆動開発による組み込みプログラミング』を読んで学んだことをまとめます。本の要約6割、追加改変4割といった感じです。

# 組み込みでTDDってできるの?
- できる。ハードウェアやOSが絡む組み込みこそやるべき。
- ユニットテストによって品質が上がるというQA的なメリットに加え、綺麗な設計になるというメリットが大きい。
	1. テストしようとする
	2. うまくテストできない(大抵は依存性の問題)
	3. テストできるように設計を見直す(依存性を取り除く)
	4. 綺麗な(SOLIDな)設計になる

# ユニットテストフレームワーク
| 名前          | 言語 | Mockサポート| その他 |
|:--------------|----:|------------:|------------:|
| Unity         | C   | cmock。Mock自体はrubyスクリプトで別途生成する必要がある | 軽量。テストケースの手動登録(インストール)が必要 |
| CppUTest      | C++ | CppUMock    | Unity用コードに変換可能らしい |
| Google Test   | C++ | GoogleMock。クラスに対してのモックが作れる。自由度高い  | pthread必須? |

ユニットテストをするのがホスト環境だけなら、今ならGoogle Test一択かな? という感じ。非Linuxのターゲットマイコン上でもユニットテストをする可能性があるときにはUnityかな。

# テストの進め方
## テストケースの書き方
- 4フェーズテストパターンに従ったテストケースにする
	- 準備 (Setup)
	- 実行 (Exercise)
	- 検証 (Verify)
	- 後片付け (Cleanup)
- 共通の準備と後片付けは、ユニットテストフレームワークが提供するテストフィクスチャのSetUp()、TearDown()にまとめられる
- 他の処理も共通化できるものはどんどんまとめるべき

## テストの進め方
1. テストコード (テストケース)を書く。__(テストファースト!!)__
2. コンパイルが通るようにする (ヘッダを作る)
3. リンクが通るようにする (空関数を作る)
4. テストが通るようにする (実実装をする)

# コラボレータ
以下の2つのモジュールを考えます。左側は計算をする`MyMath`というモジュールで、例えば、単純な足し算をする`add()`という関数を持っています。右側はLチカをするためのモジュールだと想像してください。クラス図っぽく書いていますが、Cでも同じです。

[]()

足し算をする`add()`は、依存モジュールがなく、純粋なロジックだけを扱い、入出力インターフェイスがシンプルです。そのため、テストがしやすいです。この場合は、戻り値をチェックすることでテストが出来ます。
しかし、右側の`Blink`は戻り値がありません。また、`Blink`をテストするためには、`LedDriver`が必要ですし、さらにハードウェアが必要になります。

このように、テスト対象コード(モジュール)が依存しているもの(関数、データ、モジュール、デバイス)をコラボレータと呼んでいます。
コラボレータの存在がテストを難しくさせます。これをいかにして解決するかというのが、肝になる所です。本書の内容も、ほとんどがこれにつながります。そして、これをうまいこと解決してテストがしやすくなる = SOLIDな良い設計になります。

## テストダブル
スタブやモック、ダミーといった方が一般的かと思います。テスト対象モジュールが依存しているモジュール(関数)の代わりになるものを用意します。
一番重要なのは、テスト対象モジュールが、ダミーを使っていることに気付かない、ということです。そのため、テストダブルは本物と同じインターフェイス(同じ関数型)である必要があります。

テストダブルでどこまでやるかは、テスト内容によって様々です。例えば、リンクを通すだけの空関数だったり、常に同じ固定値を返すだけだったりします。
今回は、実際にLEDを点滅させるタイミングで`turnOn`/`turnOff`関数を呼んだかどうかをチェックしてみようと思います。そのため、`テスト`から結果を見れるようにする必要があります。そのため、`LedDriverのテストダブル`には追加で`getStatus()`という関数を用意します。これによって、`Blink`が期待通りに`LedDriver`を叩いたかをチェックできます。`Blink`のテストとしてはこれで十分です。実際にLEDが光るようにハードウェアを叩くかどうかは別途`LedDriver`の方でテストをします。

[]()

## テストダブルの種類
テストダブルでどういうことをやるか、というのは知っておいた方がいいと思います。どれくらいまで労力をかけてテストダブルを作るかの目安になります。学校の試験じゃないので覚える必要はありませんが、役割に応じて一応名前がついています。

### テストダミー
リンクを通すためだけのもの。呼ばれない前提の関数に使う。

### テストスタブ
固定値を返す関数。

### テストスパイ
テスト対象モジュールが渡したパラメータを記録する。
前述の、`LedDriverのテストダブル`はこれ。

### モックオブジェクト
テスト対象モジュールが他のモジュール(関数)を呼ぶ際の、関数名、パラメータ、呼ぶ順番をチェックできる。また、戻り値の設定が出来る。
コード自体は、ユニットテストフレームワークによって用意される(Unityだとスクリプト(cmock)でヘッダファイルから生成する必要がある)。

例えば、先ほどの`Blink`が、id=3のLEDをOn, Off, On, Offするのが期待動作だとしたら、`Blink`を呼ぶ前に以下のように設定すれば、自動でチェックしてくれる。
もしも期待動作以外の呼び方をしていたら、FAILしてくれる。

```cpp:Mockの期待動作設定例(CppUTest)
mock().expectOneCall("LedDriver_turnOn").withParameter("id", 3);
mock().expectOneCall("LedDriver_turnOff").withParameter("id", 3);
mock().expectOneCall("LedDriver_turnOn").withParameter("id", 3);
mock().expectOneCall("LedDriver_turnOff").withParameter("id", 3);
```

### フェイクオブジェクト
部分的に実装したもの。

### その他
テストダブルは、テスト用に関数を追加してOK。
例えば、先ほどの`LedDriverのテストダブル`では`getStatus()`を追加しました。
他にも、例えばタイマモジュールを模擬するときには、今の時間を設定する関数を追加したりする。


## だまし方
テストダブルによって、テスト対象モジュールが依存するモジュールが無くてもテストできるし、期待動作の確認もしやすくなりました。
繰り返しになりますが、この時、テスト対象モジュールはテストダブルを使っているということを意識してはいけません。テスト対象モジュールをうまくだます必要があります。
例えば、同じ関数名で同じ型にして、リンカで切り替えるなどがあります。（先ほどの例だと、プロダクト用コードでは`LedDriver`をリンクする。テスト用には`LedDriverのテストダブル`をリンクする)

だまし方にもいろいろあります。上手くだませる = 抽象度が高い(SOLID) = 良い設計になります。


### ifdefスイッチ
あまりよろしくない。コードが汚れる。

### リンカで置き換える
プロダクト用とテスト用で明らかに分けたいときには一番楽だと思います。
ただ、例えば先ほどの`LedDriver`の場合ですと、`LedDriver`自体もテストしたいときに、困ります。

(テストとは関係ありませんが、同じ商品群でも型番によって使用するデバイスが違うときなんかにも使います。)

### 関数ポインタで置き換える
動的に置き換えが出来ます。そのため、あるテストではテストダブルを使うが、別のテストではプロダクト用コードを使う、といったことが出来ます。
欠点としては、コードが複雑になります。関数を呼んだときに、実際にどの処理が走るかが一目でわからないし、IDEの関数ジャンプも使えなくなります。(Grepして、設定している所を調べる必要がある)

まず、関数定義を関数ポインタにします。その後、実実装の関数で代入します。基本はこれが動きます。

```c:LedDriver.h
// void LedDriver_turnOn(int id);
extern void (*LedDriver_turnOn)(int id);
```

```c:LedDriver.c
// void LedDriver_turnOn(int id)
static void LedDriver_turnOn_impl(int id)
{
	/* LEDをONにする実処理(プロダクト用コード) */
}

void (*LedDriver_turnOn)(int id) = LedDriver_turnOn_impl;
```

置き換え用のテストダブルを用意します。今まで名前を付けずに`LedDriverのテストダブル`と言っていましたが、とりあえず`FakeLedDriver`とします。

```c:FakeLedDriver.c
static int ledStatus[16];
void FakeLedDriver_turnOn(int id)
{
	ledStatus[id] = 1;
}

void FakeLedDriver_getStatus(int id)
{
	return ledStatus[id];
}
```

実際にテストする前後で置き換えます。

```c:BlinkTest.c
TEST(BlinkTest, SampleTest)
{
	void (*save)(int id) = LedDriver_turnOn;
	LedDriver_turnOn = FakeLedDriver_turnOn;
	Blink_start();
	LONGS_EQUAL(1, FakeLedDriver_getStatus(3));
	LedDriver_turnOn = save;
}
```

### 関数ポインタで置き換える(テーブル管理)
置き換える関数の数が増えてきたら、同じモジュールのものは構造体を定義して、テーブルとして管理。

```c
typedef struct {
	void (*turnOn)(int id);
	void (*turnOff)(int id);
} LIGHT_FUNC_TABLE;

LIGHT_FUNC_TABLE ioFuncTable = {
	.turnOn = LedDriver_turnOn,
	.turnOff  = LedDriver_turnOff,
};
```


### 依存性の注入
そもそも、`Blink`が直接`LedDriver`を呼んでいるから、色々とだます必要がありました。
例えば以下のように、`Blink`の呼び元(この場合は`テスト`)がどの関数を呼ぶかを指定できるようにすれば、よりスマートになります。

[]()

```c:BlinkTest.c
TEST(BlinkTest, SampleTest)
{
	Blink_setFunc(FakeLedDriver_turnOn, FakeLedDriver_turnOff);
	Blink_start();
	LONGS_EQUAL(1, FakeLedDriver_getStatus(3));
}
```

このようにすることを、「依存性の注入」といいます。
嬉しい副作用があります。今回はプロダクト用コードとテスト用コードの置き換えだけでした。しかし、将来的にBlink(点滅)させるのをLEDだけでなく、電球や蛍光灯にも対応させたいという要求があったとします。この時、`Blink`モジュールはそのまま再利用できます。`LightBulbDriver_turnOn()`や`LampDriver_turnOn()`といった関数を同じ型で作り、それを突っ込むだけで対応完了します。

### 依存性の注入(Interfaceを使う)
先ほどの例では、関数をそのまま突っ込みましたが、実際にはInterfaceを使うと思います。
下図のように、`IDriver`と同じインターフェイスを持つモジュールであれば、テスト用のテストダブルであろうと、他の照明器具用ドライバであろうと、どんなモジュールにも置き換えることが出来ます。
なお、この図ではC++のクラス図っぽく書いていますが、Cでクラスやインターフェイスを実現する方法もあります。実際に本書では、Cでvtableを使った実現方法について結構なページ数を割いて説明しています。

[]()


### 依存性の注入(簡易版)
実は、本書ではまず`LedDriver`のテストから説明されていました。LedDriverはハードウェアを制御します。
これをテストできるようにするため、本書では`LedDriver`に対してメモリマップドレジスタのアドレスを設定することでテスト可能としていました。これも、依存性の注入になります。
プロダクト用コードではレジスタアドレス(e.g. 0xF800_0000)を設定し、テスト用コードでは適当なメモリ領域を設定することで、テスト、書き込んだ値のチェックが出来ます。

[]()

当然これも、Interfaceを用いて、下記のようにすることもできます。どこまでやるかは、正解はなく、状況に応じて変わってくると思います。使用するテストダブルも、自分で作っても良いですし、Mockを使って書き込み値のチェックもできます。

[]()


## コラボレータまとめ
- コラボレータを置き換えるテストダブルには種類がある。何をどこまでチェックするかによって、使い分ける。
- コラボレータの置き換え方法も色々ある。場合によっては設計にも影響する（大抵は設計をより良くする）。

本書の内容もほとんどは、上記2点に関連することになります。重要なんだと思います。


# 割り込みやコールバックは?
これまで、テスト対象モジュールの外部への依存(コラボレータ)をどう解決するかを見てきました。いずれも、 __テスト対象モジュールが呼んでいるケース__ です。
割り込みやコールバック等、 __テスト対象モジュールが呼ばれるケース__ はどうでしょうか? 例えばLチカ用のBlinkモジュールは、タイマ割り込みを直接受けたり、または、別のタイマモジュールにコールバック登録していることもあり得ます。

特に本書では触れられていませんでしたが、基本的には「`テスト`から該当関数を呼ぶ」でいいかなと思います。ただ、割り込みハンドラそのものを呼ぶのではなく、テストできる単位で呼ぶのがいいかと思います。そのようになっていないときは、コードを見直す必要があるかと思います。コールバックも同様かと。

```c:割り込みハンドラでの処理
__INTR void irq_timer0()
{
	timeCounter++;
	その他いろいろの処理
}
```

```c:割り込みハンドラでの処理(コード見直し後)
__INTR void irq_timer0()
{
	incrementTimeCounter();
	etcProcess0();
	etcProcess1();
}
```

```c:テスト
TEST(BlinkTest, TimerIncrement)
{
	extern void incrementTimeCounter();
	incrementTimeCounter();
}
```

# 教育大事
テストというか一般的なことになりますが、メンバーへの教育は非常に大事だと思います。

例えば、先ほどの関数ポインタで置き換えるという例ですが、これはテスト用に限らずしばしば使われるテクニックだと思います。ただし、初見だと何をやっているのか全く分からなかったり、知っていても実際の処理がどこにあるのかを探すのに時間を費やしたりします。場合によってはICEで追っかけたり。。。

また、複数のモジュール(または処理)を切り替えるのに、switch-caseではなく、インターフェイスを使うというのもよくあるテクニックだと思います。これも、拡張性を持たせるためにせっかく頑張って設計しても、他のメンバーに正しく伝わっていないと、結局switch-case文だらけになってしまったりします。

(どちらも僕が新卒エンジニアのときにやったことです。。。)

# おわりに
本書のサンプルコードは、前半はUnityで、後半はCppUTestで書かれています。
Unity、CppUTest、GoogleTestのそれぞれで10章までの写経をしたので、よろしければ参考にしてみてください。また、各種モックも使ってみました。
https://github.com/take-iwiw/TDD_EmbeddedC

おまけに、Unity用にテストケースからテストランナーを生成するスクリプトを作りました。(https://github.com/take-iwiw/TDD_EmbeddedC/blob/master/Unity/generate_TEST_RUNNER.py)
(Unity公式のrubyスクリプトでも似たことはできるのですが、テストグループごとにmain関数が作られてしまうっぽいので、シンプルにコード生成だけをするスクリプトを作りました。)


もっと早くにこの本を読んでおけばよかったです。個人的には、今まで読んできた技術書の中で断トツで良かったです。ちなみにこれまでのトップはCODE COMPLETE。

